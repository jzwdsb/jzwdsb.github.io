<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"jzwdsb.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.13.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="manout&#39;s blog">
<meta property="og:url" content="http://jzwdsb.github.io/page/3/index.html">
<meta property="og:site_name" content="manout&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="manout">
<meta property="article:tag" content="Developer,Programmer,Coder,Geek">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://jzwdsb.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>manout's blog</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">manout's blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Something about me</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section">标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section">分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="manout"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">manout</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">182</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/jzwdsb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jzwdsb" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/manout0316@gmail.com" title="E-Mail → manout0316@gmail.com"><i class="email fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/jia-zhen-wei-93%20|%20%E7%9F%A5%E4%B9%8E" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;jia-zhen-wei-93 | 知乎" rel="noopener" target="_blank">知乎</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://jzwdsb.github.io/2019/02/27/next_canvax/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="manout">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="manout's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | manout's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/27/next_canvax/" class="post-title-link" itemprop="url">next 主题背景添加 canvas nest 特效</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-27 20:00:00" itemprop="dateCreated datePublished" datetime="2019-02-27T20:00:00+08:00">2019-02-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-18 09:44:32" itemprop="dateModified" datetime="2022-10-18T09:44:32+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/blog/" itemprop="url" rel="index"><span itemprop="name">blog</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>之前记得看到有些博客背景有可以用鼠标吸引的几何线条，很是喜欢，一直想加到自己博客里面。</p>
<p>theme 是 nexT, 在 <code>themes/next/layout/_layout.swig</code> 的 body 块中添加如下内容即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; color=&quot;0,0,0&quot; opacity=&#x27;0.5&#x27; zIndex=&quot;-1&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当然也可以 <code>npm install --save canvas-nest.js</code>, 只是不太可控</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://jzwdsb.github.io/2019/02/27/redis_start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="manout">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="manout's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | manout's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/27/redis_start/" class="post-title-link" itemprop="url">redis 的启动过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-27 15:00:00" itemprop="dateCreated datePublished" datetime="2019-02-27T15:00:00+08:00">2019-02-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-18 09:44:32" itemprop="dateModified" datetime="2022-10-18T09:44:32+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>redis 大体上可以分为两部分: 服务端和客户端。观察下服务端启动时都做了下哪些事。</p>
<p>Redis 全部由 C 语言编写，main 函数写在 server.c 中，启动主要分为以下几步</p>
<ul>
<li>初始化全局服务器状态:</li>
<li>设置 commend table</li>
<li>初始化哨兵模式</li>
<li>修复持久化文件</li>
<li>处理参数</li>
<li>initServer</li>
<li>Shared object</li>
<li>Shared integers</li>
<li>新增循环事件</li>
<li>分配数据库</li>
<li>监听 TCP 端口</li>
<li>初始化 LRU 键池</li>
<li>Server Cron</li>
<li>打开 AOF 文件</li>
<li>最大内存限制</li>
<li>Redis Server 启动</li>
<li>从磁盘加载数据</li>
<li>最后设置</li>
<li>进入循环主事件</li>
</ul>
<h1 id="初始化全局服务器状态"><a href="#初始化全局服务器状态" class="headerlink" title="初始化全局服务器状态"></a>初始化全局服务器状态</h1><p>如果 redis-server 命令启动时使用了 <code>test</code> 参数，那么就会先进行指定的测试。接下来调用了 <code>initServerConfig</code> 函数，这个函数初始化了一个类型为 <code>redisServer</code> 的全局变量 Server.<br><code>redisServer</code> 这个结构包含了非常多的字段，按类别划分，可以分为以下类别。</p>
<ul>
<li>General</li>
<li>Modules</li>
<li>NetWorking</li>
<li>RDB &#x2F; AOF load information</li>
<li>Faster Pointers to offten lookup command</li>
<li>Fields used only for stats</li>
<li>Configuration</li>
<li>AOF &#x2F; RDB persistence</li>
<li>Loggin</li>
<li>Replicaion</li>
<li>Synchronous replication</li>
<li>Limits</li>
<li>Blocked clients</li>
<li>Sort parameter</li>
<li>Zip structure config</li>
<li>time cache</li>
<li>Pubsub</li>
<li>Cluster</li>
<li>Scripting</li>
<li>Lazy free</li>
<li>Assert &amp; bug reporting</li>
<li>System hardware info</li>
</ul>
<p><code>initServerConfig</code> 的主要工作是给可以在配置文件中(redis.conf)中配置的变量初始化一个默认值。比较常用的变量有服务器端口号，日志等级等。</p>
<h1 id="设置-command-table"><a href="#设置-command-table" class="headerlink" title="设置 command table"></a>设置 command table</h1><p>在 <code>initServerConfig</code> 函数，会调用 <code>populateCommandTable</code> 函数来设置服务器的命令表，命令表的结构如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">redisCommand</span> redisCommandTable[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;module&quot;</span>, moduleCommand, <span class="number">-2</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;get&quot;</span>, getCommand, <span class="number">2</span>, <span class="string">&quot;rF&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;set&quot;</span>, setCommand, <span class="number">-3</span>, <span class="string">&quot;wm&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;set&quot;</span>, setCommand, <span class="number">-3</span>, <span class="string">&quot;wm&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setnx&quot;</span>, setnxCommand, <span class="number">3</span>, <span class="string">&quot;wmF&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一项分别代表</p>
<ul>
<li>name: 命令的名称</li>
<li>function: 命令对应的函数句柄</li>
<li>arity: 命令的参数个数, 如果为 <code>-N</code> 表示大于等于 N</li>
<li>sflags: 命令标志, 标识命令的类型(read&#x2F;write&#x2F;admin)</li>
<li>flags: 位掩码，可由 Redis 根据 sflags 计算</li>
<li>get_keys_proc: 可选函数，当下面三个不能哪些参数是 key 时使用</li>
<li>first_key_index: 第一个是 key 的参数</li>
<li>last_key_index: 最后一个是 key 的参数</li>
<li>key_step: key 的步长，比如 MSET 的 key_step 是 2, 因为某些命令的参数是 key,val,key,val 这样的形式</li>
<li>microseconds: 执行命令需要的微秒数</li>
<li>calls: 该命令被调用总次数</li>
</ul>
<p>设置好命令表后，redis-server 还会对一些常用的命令设置快速查找方式，直接赋予 server 的成员指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.delCommand = <span class="built_in">lookupCommandByCstring</span>(<span class="string">&quot;del&quot;</span>);</span><br><span class="line">server.multiCommand = <span class="built_in">lookupCommandByCString</span>(<span class="string">&quot;multi&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="初始化哨兵模式"><a href="#初始化哨兵模式" class="headerlink" title="初始化哨兵模式"></a>初始化哨兵模式</h1><p>变量初始化后，就会将启动命令的路径和参数保存起来，方便下次重启的时候使用。如果启动的服务是哨兵模式，那么就会调用 <code>initSentinelConfig</code> 和 <code>initSentinel</code> 初始化哨兵模式。关于哨兵模式会在另一篇博文里介绍。<br><code>initSentinelConfig</code> 和 <code>initSentinel</code> 都在 <code>sentinel.c</code> 文件中。<code>initSentinelConfig</code> 函数负责初始化 sentinal 的端口号，以及解除服务器的保护模式。<br><code>initSentinel</code> 函数负责将 command table 设置为只支持 sentinal 命令，以及初始化 <code>sentinalState</code> 数据格式。</p>
<h1 id="修复持久化文件"><a href="#修复持久化文件" class="headerlink" title="修复持久化文件"></a>修复持久化文件</h1><p>启动模式如果是 <code>redis-check-rdb/aof</code>, 那么就会执行 <code>redis_check_rdb_main</code> 或 <code>redis_check_aof_main</code> 这两个函数来修复持久化文件，不过 <code>redis_check_rdb_main</code> 函数所做的事情在 <code>Redis</code> 启动过程中已经做了，所以这里不需要做，直接使用这个函数就可以。</p>
<h1 id="处理参数"><a href="#处理参数" class="headerlink" title="处理参数"></a>处理参数</h1><p>如果是简单的参数例如 <code>-v</code> 或 <code>--version</code>, <code>-h</code> 或 <code>--help</code>, 就会直接调用响应的方法，打印信息。如果是使用其他配置文件，则修改 <code>server.exec_argv</code>. 对于其他信息，会将其转换为字符串，然后添加进配置文件，例如 <code>--port 6380</code> 就会转换成 <code>port 6380\n</code> 加进配置文件。此时，redis 就会调用 <code>loadServerConfig</code> 函数来加载配置文件，这个过程会覆盖前面初始化默认配置文件的变量的值。</p>
<h1 id="initServer"><a href="#initServer" class="headerlink" title="initServer"></a>initServer</h1><p>initServer 函数负责结束 server 变量初始化工作。首先设置处理信号(<code>SIGHUP</code> 和 <code>SIGPIPE</code> 除外), 接着会创建一些双向列表用来跟踪客户端，从节点等.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server.current_client = <span class="literal">NULL</span>;</span><br><span class="line">server.clients = <span class="built_in">listCreate</span>();</span><br><span class="line">server.client_index = <span class="built_in">raxNew</span>();</span><br><span class="line">server.client_to_close = <span class="built_in">listCreate</span>();</span><br><span class="line">server.slaves = <span class="built_in">listCreate</span>();</span><br><span class="line">server.monitors = <span class="built_in">listCreate</span>();</span><br><span class="line">server.client_pending_write = <span class="built_in">listCreate</span>();</span><br><span class="line">server.slaveseldb = <span class="number">-1</span>;</span><br><span class="line">server.unblocked_clients = <span class="built_in">listCreate</span>();</span><br><span class="line">server.ready_keys = <span class="built_in">listCreate</span>();</span><br><span class="line">server.client_waiting_acks = <span class="built_in">listCreate</span>();</span><br></pre></td></tr></table></figure>

<h1 id="Shared-object"><a href="#Shared-object" class="headerlink" title="Shared object"></a>Shared object</h1><p><code>createSharedObject</code> 函数会创建一些 shared 对象保存在全局的 <code>shared</code> 变量中，对于不同的命令，可能会有相同的返回值。这样返回时就不需要新增对象，保存到内存中。<br>这样设计以启动 Redis 时多消耗一些时间为代价，换取运行的更小的延迟</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shared.crlf = createObject(OBJ_STRING, sdsnew(<span class="string">&quot;\r\n&quot;</span>));</span><br><span class="line">shared.ok = createObject(OBJ_STRING, sdsnew(<span class="string">&quot;+OK\r\n&quot;</span>));</span><br><span class="line">shared.err = createObject(OBJ_STRING, sdsnew(<span class="string">&quot;-ERR\r\n&quot;</span>));</span><br><span class="line">shared.emptybulk = createObject(OBJ_STRING, sdsnew(<span class="string">&quot;$0\r\n\r\n&quot;</span>));</span><br><span class="line">shared.czero = createObject(OBJ_STRING, sdsnew(<span class="string">&quot;:0\r\n&quot;</span>));</span><br></pre></td></tr></table></figure>

<h1 id="shared-integers"><a href="#shared-integers" class="headerlink" title="shared integers"></a>shared integers</h1><p>除了上述的一些返回值以外，<code>createSharedObject</code> 函数还会创建一些共享的整数对象。对 Redis 来说，有许多类型 (比如 lists 或者 sets) 都需要一些整数 (比如数量), 这是就可以复用这些已经创建好的整数对象，而不需要重新分配内存并创建。这同样是牺牲了启动时间来换取运行时间。</p>
<h1 id="新增循环事件"><a href="#新增循环事件" class="headerlink" title="新增循环事件"></a>新增循环事件</h1><p><code>initServer</code> 函数调用 <code>aeCreateEventLoop</code> 函数 (<code>ae.c</code> 文件)来增加循环事件，并将结果返回给 server 的 el 成员。Redis 使用不同的函数来兼容各个平台，在 Linux 平台使用 <code>epoll</code>, 在 BSD 使用 <code>kqueue</code>, 都不是的话，最终会使用 <code>select</code>. Redis 轮询新的连接以及 I&#x2F;O 事件，有新的事件到来时就会及时作出响应。</p>
<h1 id="分配数据库"><a href="#分配数据库" class="headerlink" title="分配数据库"></a>分配数据库</h1><p>Redis 初始化需要的数据库，并将结果赋予 server 的 db 成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.db = <span class="built_in">zmalloc</span>(<span class="built_in">sizeof</span>(redisDb) * server.dbnum);</span><br></pre></td></tr></table></figure>

<h1 id="监听-TCP-端口"><a href="#监听-TCP-端口" class="headerlink" title="监听 TCP 端口"></a>监听 TCP 端口</h1><p><code>listenToPort</code> 用来初始化一些文件描述符，从而监听 server 配置的地址和端口。<code>listenToPort</code> 函数会根据参数中的地址判断要监听的是 IPv4 还是 IPv6, 对应的调用 <code>anetTcpServer</code> 或者 <code>anetTcp6Server</code> 函数，如果参数中未指明地址，最会强行绑定 <code>0.0.0.0</code></p>
<h1 id="初始化-LRU-键池"><a href="#初始化-LRU-键池" class="headerlink" title="初始化 LRU 键池"></a>初始化 LRU 键池</h1><p><code>evictionPoolAlloc</code> (evict.c 文件中) 用于初始化 LRU 的键池，Redis 的 key 过期策略是近似 LRU 算法.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">evictionPoolAlloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">evictionPoolEntry</span> *ep;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    ep = <span class="built_in">zmalloc</span>(<span class="built_in">sizeof</span>(*ep)*EVPOOL_SIZE);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; EVPOOL_SIZE; j++) &#123;</span><br><span class="line">        ep[j].idle = <span class="number">0</span>;</span><br><span class="line">        ep[j].key = <span class="literal">NULL</span>;</span><br><span class="line">        ep[j].cached = <span class="built_in">sdsnewlen</span>(<span class="literal">NULL</span>, EVPOOL_CACHED_SDS_SIZE);</span><br><span class="line">        ep[j].dbid = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    EvictionPoolLRU = rp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="server-cron"><a href="#server-cron" class="headerlink" title="server cron"></a>server cron</h1><p><code>initServer</code> 函数接下会为数据库和 pub&#x2F;sub 再生成一些列表和字段，重置一些状态，标记系统启动时间。在这之后，Redis 会执行 <code>aeCreateTimeEvent</code> (在 <code>ae.c</code> 文件中) 函数，用来新建一个循环执行 <code>serverCron</code> 函数的事件。<code>serverCron</code> 默认每 100 毫秒执行一次.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">aeCreateTimeEvent</span>(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">    <span class="built_in">serverPanic</span>(<span class="string">&quot;Can&#x27;t create event loop timers.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，代码中创建循环事件时指定每毫秒执行一次 <code>serverCron</code> 函数，这是为了使循环马上启动，但是 <code>serverCron</code> 函数的返回值又会被作为下次执行的时间间隔。默认为 1000&#x2F;server.hz.<br><code>server.hz</code> 随着客户端数量的增加而增加。</p>
<p><code>serverCron</code> 函数做了许多定时执行的任务，包括 <code>rehash</code>, 后台持久化，AOF 重新与清理，清理过期 key, 交换虚拟内存，同步主从节点等等。总之能想到的 Redis 的定时任务几乎都在 <code>serverCron</code> 函数中处理。</p>
<h1 id="打开-AOF-文件"><a href="#打开-AOF-文件" class="headerlink" title="打开 AOF 文件"></a>打开 AOF 文件</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.aof_state == AOF_ON) &#123;</span><br><span class="line">    server.aof_fd = <span class="built_in">open</span>(server.aof_filename,</span><br><span class="line">                         O_WRONLY | O_APPEND| O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (server.aof_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">serverLog</span>(LL_WARNING, <span class="string">&quot;Can&#x27;t open the append-only file:%s&quot;</span>,</span><br><span class="line">                  <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最大内存限制"><a href="#最大内存限制" class="headerlink" title="最大内存限制"></a>最大内存限制</h1><p>对于 32 位系统，最大内存是 4GB, 如果用户没有明确指出 Redis 可使用的最大内存，那么这里默认限制为 3GB.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.arch_bits == <span class="number">32</span> &amp;&amp; server.maxmemory == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">serverLog</span>(LL_WARNING, <span class="string">&quot;WARNING: 32 bit instance detected but no memory set. Setting 3 GB maxmemory limit with &#x27;noeviction&#x27; policy now.&quot;</span>);</span><br><span class="line">    server.maxmemory = <span class="number">3072L</span> * (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    server.maxmemory_policy = MAXMEMORY_NO_EVICTION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Redis-Server-启动"><a href="#Redis-Server-启动" class="headerlink" title="Redis Server 启动"></a>Redis Server 启动</h1><p>如果 Redis 被设置为后台运行，此时 Redis 会尝试写 pid 文件，默认路径是 <code>/var/run/redis.pid</code>. 这时，Redis 服务器已经启动。</p>
<h1 id="从磁盘加载数据"><a href="#从磁盘加载数据" class="headerlink" title="从磁盘加载数据"></a>从磁盘加载数据</h1><p>如果存在 AOF 文件或者 dump 文件 (都有的话 AOF 文件的优先级高), <code>loadDataFromDisk</code> 函数负责将数据从磁盘加载到内存</p>
<h1 id="最后的设置"><a href="#最后的设置" class="headerlink" title="最后的设置"></a>最后的设置</h1><p>每次进入循环事件时，要调用 <code>beforeSleep</code> 函数，主要做如下工作</p>
<ul>
<li>如果 server 时 cluster 中的一个节点，调用 <code>clusterBeforeSleep</code> 函数</li>
<li>执行一个快速的周期</li>
<li>如果有客户端在前一个循环事件被阻塞了，向所有的从节点发送 ACK 请求</li>
<li>取消在同步备份过程中被阻塞的客户端的阻塞状态</li>
<li>检查是否有因为阻塞命令而被阻塞的客户端，如果有，解除</li>
<li>把 AOF 缓冲区写入磁盘</li>
<li>线程释放 GIL</li>
</ul>
<h1 id="进入主循环事件"><a href="#进入主循环事件" class="headerlink" title="进入主循环事件"></a>进入主循环事件</h1><p>程序调用 <code>aemain</code> 函数，进入主循环，这是其他的一些循环事件也会分别被调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">aemain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop -&gt; stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop -&gt; stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop -&gt; beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop -&gt; <span class="built_in">beforesleep</span>(eventLoop);</span><br><span class="line">        <span class="built_in">aeProcessEvents</span>(eventLoop, AE_ALL_EVENTS | AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行到这里，Redis server 已经准备好处理各种时间了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://jzwdsb.github.io/2019/02/26/redis_exec_command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="manout">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="manout's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | manout's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/26/redis_exec_command/" class="post-title-link" itemprop="url">redis 执行命令的过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-26 15:00:00" itemprop="dateCreated datePublished" datetime="2019-02-26T15:00:00+08:00">2019-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-18 09:44:32" itemprop="dateModified" datetime="2022-10-18T09:44:32+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>redis 的在启动后创建了一些循环事件来监听 TCP 端口和 Unix 的 Sockets, 从而使 redis 服务器可以接受新的连接，之后就可接受来自 client 的请求和命令。<br>中间的过程主要分为以下几步</p>
<ul>
<li><a href="#%E5%A4%84%E7%90%86%E6%96%B0%E8%BF%9E%E6%8E%A5">处理新连接</a></li>
<li><a href="#%E8%AF%BB%E4%B8%80%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%91%BD%E4%BB%A4">读一个客户端的命令</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E5%B9%B6%E8%BF%94%E5%9B%9E">执行命令并返回</a></li>
</ul>
<h1 id="处理新连接"><a href="#处理新连接" class="headerlink" title="处理新连接"></a>处理新连接</h1><p>redis 在 initServer() 函数中创建循环事件调用了 <code>acceptTcpHandler</code> 和 <code>acceptUnixHandler</code> 函数来处理接受到的 TCP 连接和 Unix 的 Sockets 连接。这两个函数又调用了 <code>acceptCommonHandler</code>, 在这个函数中又调用了 <code>createClient</code> 函数创建了一个新的 client 对象，用来表示一个新的客户端连接</p>
<p><code>createClient</code> 的工作主要如下</p>
<p>首先为变量 c 分配了内存，接着将 Socket 连接置为非阻塞状态，并且设置了 TCP 无延迟。然后创建了 File 循环事件(<code>asCreateFileEvent</code>) 来调用 <code>readQueryFromClient</code>. 新建的客户端默认连接的是服务器的第一个数据库(编码为 0), 最后设置好客户端的各种属性和状态.</p>
<h1 id="读一个客户端的命令"><a href="#读一个客户端的命令" class="headerlink" title="读一个客户端的命令"></a>读一个客户端的命令</h1><p><code>readQueryFromClient</code> 函数就是用来从客户端读取命令的，具体实现如下</p>
<p>Redis 会先将命令读入缓冲区，一次最多读取的大小是 <code>PROTO_IOBUF_LEN</code>(1024 x 16) bit. 然后调用 <code>processInputBufferAndReplicate</code> 函数, 来处理缓冲区中的数据，如果客户端时 master(主从同步过程), 那么 Redis 就会计算前后缓冲区的不同部分，以确定从节点接受了多少数据。<br><code>processInputBufferAndReplicate</code> 函数会处理客户端向服务器发送命令和主节点向从节点发送命令这两种情况，不过最后都需要调用 <code>processInputBuffer</code> 函数.</p>
<p><code>processInputBufferAndReplicate</code> 函数会先判断客户端是否正常，如果出现连接中断或者客户端阻塞等情况，就会立即停止命令。然后根据读取的请求生成 Redis 可以执行党的命令(包括参数). 不同的请求类型分别调用 <code>processInlineBuffer</code> 和 <code>processMultbulkBuffer</code> 函数，生成好命令之后，交给 <code>procssCommand</code> 执行，如果返回 <code>C_OK</code> 则重置客户端，等待下一个命令。如果返回的是 <code>C_ERR</code>, 客户端就会销毁。(比如执行 <code>QUIT</code> 命令</p>
<p><code>processCommand</code> 函数会从 Redis 启动时加载的命令表中查找命令，然后检查命令的执行权限。</p>
<p>如果是 cluster, 这是会判断 key 是否属于当前的 master, 不属于返回重定向信息。</p>
<p>如果内存不够用，这里也需要判断一下是够有可以释放的内存，如果没有，就不能执行命令，返回错误信息。</p>
<p>接下来判断一些不能接受写命令的情况</p>
<ul>
<li>服务器不能进行持久化</li>
<li>作为 master, 没有足够的可用的 slave</li>
<li>此服务器为只读的 slave, 只有它的 master 可以接受命令</li>
</ul>
<p>在订阅模式中，只能接受指定的命令</p>
<ul>
<li>(P) <code>SUBSCRIBE</code></li>
<li>(P) <code>UNSUBSCRIBE</code></li>
<li><code>PING</code></li>
<li><code>QUIT</code></li>
</ul>
<p>当 slave 和 master 失联时，只能接受有 flag <code>t</code> 的命令，例如 <code>INFO</code>, <code>SLAVEOF</code></p>
<p>如果命令没有 <code>CMD_LOADING</code> 标志，并且当前服务器正在加载数据，则不能接受此命令</p>
<p>对 lua 脚本长度进行限制</p>
<p>当进行完上述的各种条件判断后，才真正开始调用 <code>call</code> 函数执行命令</p>
<h1 id="执行命令并返回"><a href="#执行命令并返回" class="headerlink" title="执行命令并返回"></a>执行命令并返回</h1><p><code>call</code> 函数的参数是 client 类型，取出 cmd 成员进行执行.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dirty = server.dirty;</span><br><span class="line">start = <span class="built_in">ustime</span>();</span><br><span class="line">c-&gt;cmd-&gt;<span class="built_in">proc</span>(c);</span><br><span class="line">duration = <span class="built_in">ustime</span>() - start;</span><br><span class="line">dirty = server.dirty - dirty;</span><br><span class="line"><span class="keyword">if</span> (dirty &lt; <span class="number">0</span>) dirty = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>如果是写命令，就是在服务器上产生脏数据，服务器需要标记下内存中的某些有了改变。这对于 Redis 的持久化来说非常重要，它可以知道这个命令影响了多少个 key. 命令执行完毕后并没有结束，call 函数还会进行一些其他操作。例如记录日志，写 AOF 文件，向从节点同步命令等。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://jzwdsb.github.io/2019/02/26/kafka_high_performence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="manout">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="manout's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | manout's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/26/kafka_high_performence/" class="post-title-link" itemprop="url">kafka 高性能原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-26 14:00:00" itemprop="dateCreated datePublished" datetime="2019-02-26T14:00:00+08:00">2019-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-18 09:44:32" itemprop="dateModified" datetime="2022-10-18T09:44:32+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>从架构层面和具体实现层面分析了 kafka 如何实现高性能</p>
<h1 id="架构层面"><a href="#架构层面" class="headerlink" title="架构层面"></a>架构层面</h1><h2 id="partition-实现并行处理"><a href="#partition-实现并行处理" class="headerlink" title="partition 实现并行处理"></a>partition 实现并行处理</h2><p>kafka 是基于订阅-发布的消息系统，无论是发布还是订阅，都需要指定 topic, topic 只是一个逻辑上的概念。每个 topic 都包含一个或者或者多个 partition, 不同 partition 可位于不同节点。同时 partition 在物理上对应一个本地文件夹，每个 Partition 包含一个或多个 Segment, 每个 Segment 包含一个数据文件和一个与之对应的索引文件。<br>Partition 可位于不同机器，因此可以充分利用集群优势，实现机器间的并行处理。另一方面，由于 Partition 在物理上对应一个文件夹，即使多个 Partition 位于同一个节点，也可以通过配置让同一节点上的不同 Partition 置于不同 disk drive 上，从而实现磁盘的并行处理，充分发挥多磁盘的优势。</p>
<p>注: 虽然一个 Partition 可以分为多个 Segment, 但是 Segment 并不能提供并行处理。</p>
<h2 id="常用数据复制及一致性方案"><a href="#常用数据复制及一致性方案" class="headerlink" title="常用数据复制及一致性方案"></a>常用数据复制及一致性方案</h2><h3 id="master-slave"><a href="#master-slave" class="headerlink" title="master-slave"></a>master-slave</h3><ul>
<li>RDBMS 的读写分离即为典型的 Master-Slave 方案</li>
<li>同步复制可保证强一致性但会影响可用性</li>
<li>异步复制可提供高可用性但是会降低一致性</li>
</ul>
<h3 id="WNR"><a href="#WNR" class="headerlink" title="WNR"></a>WNR</h3><ul>
<li>主要用于去中心化的分布式系统中。</li>
<li>N 代表总副本数，W 代表每次写操作要保证的最少写成功的副本数，R 代表每次读至少要读取的副本数</li>
<li>当 W + R  &gt; N 时，可保证每次读取的数据至少有一个副本拥有最新的数据</li>
<li>多个写皂搓的顺序难以保证，可能导致多副本间的写操作顺序不一致。</li>
</ul>
<h3 id="Paxos-及其变种"><a href="#Paxos-及其变种" class="headerlink" title="Paxos 及其变种"></a>Paxos 及其变种</h3><ul>
<li>Google 的 Chubby, Zookeeper 的原子广播协议</li>
</ul>
<h3 id="基于-ISR-的数据复制方案"><a href="#基于-ISR-的数据复制方案" class="headerlink" title="基于 ISR 的数据复制方案"></a>基于 ISR 的数据复制方案</h3><p>kafka 的数据复制是以 Partition 为单位的。而多个备份间的数据复制，通过 Follower 向 Leader 拉取数据完成。类似于 Master-Slave 方案，但是 Kafka 既不是完全的同步复制，也不完全的异步复制，而是基于 ISR 的动态复制方案。</p>
<p>ISR 由 Leader 动态维护。如果 Follower 不能跟上 Leader, 他会被 Leader 从 ISR 中移除，待它又重新跟上 Leader 后，会被 Leader 再次加入 ISR 中。每次改变 ISR 后，Leader 都会将最新的 ISR 持久化到 Zookeeper 中。</p>
<p>0.8.* 版本，如果 Follower 在 <code>replica.lag.time.max.ms</code> 时间内未向 Leader 发送 Fetch 请求(也即数据复制请求), 则 Leader 会将其从 ISR 中移除。如果某 Follower 持续向 Leader 发送 Fetch 请求，但是与 Leader 的数据差距在 <code>replica.lag.max.messages</code> 以上，也会被 Leader 从 ISR 中移除.</p>
<p>Leader 并不是等到前一条消息被 Commit 才接受后一条消息。Leader 按顺序接受大量消息，最新的一条消息的 offset  被记为 High Watermark. 只有被 ISR 中所有 follower 都复制过去的消息才会 commit, Consumer 只能消费被 Commit 的消息。由于 Follower 的复制时严格按照书序，所以被 commit 的消息之前的消息肯定也已经被 Commit 过。换句话，High Watermark 标记的是 Leader 所保存的最新消息的 offet, commit offset 标记的是最新的可被消费(已同步到 ISR 中的 Follower)消息。而 Leader 对数据的接受与 Follower 对数据的复制是异步进行的，因此会出现 Commit Offset 与 High Watermark 存在一定的情况。</p>
<h1 id="具体实现层面"><a href="#具体实现层面" class="headerlink" title="具体实现层面"></a>具体实现层面</h1><h1 id="kafka-在读写上的优化"><a href="#kafka-在读写上的优化" class="headerlink" title="kafka 在读写上的优化"></a>kafka 在读写上的优化</h1><h2 id="磁盘顺序写"><a href="#磁盘顺序写" class="headerlink" title="磁盘顺序写"></a>磁盘顺序写</h2><p>kafka 在将消息写入磁盘时全是顺序写操作，目前大部分磁盘还是机械结构，顺序写要比随机写的效率高很多，避免了大量缓慢的机械运动。<br>过于频繁的小 I&#x2F;O 操作会拖慢速度，所以 kafka 会将一批次消息打包到一起批量写回磁盘。</p>
<h2 id="充分利用-page-cache"><a href="#充分利用-page-cache" class="headerlink" title="充分利用 page cache"></a>充分利用 page cache</h2><p>通过 MMAP, 利用 page cache, 这是 os 级别的缓存而不是应用级别的，所以 kafka 重启后仍然可用。<br>读操作可直接在 page cache 内进行。如果消费和生产速度相当，甚至不需要通过物理磁盘(直接通过 page cache) 交换数据.</p>
<h2 id="支持多-Disk-Drive"><a href="#支持多-Disk-Drive" class="headerlink" title="支持多 Disk Drive"></a>支持多 Disk Drive</h2><p>Broker 的 <code>log.dirs</code> 配置项，允许配置多个文件夹。如果机器上有多个 Disk Drive, 可将不同的 Disk 挂载到不同的目录，然后将这些目录都配置到 <code>log.dirs</code> 里，kafka 会尽可能将不同的 Partition 分配到不同的目录，也即不同的 Disk 上面，充分利用多 Disk 的优势.</p>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>当需要网络传输日志时，比如传输持久性日志块，常规的接口从传输需要四次拷贝。<br>在使用 MMAP 时，可以使用 Linux 提供的传输接口 <code>sendfile</code> 系统调用，直接从页缓存复制到 socket 中进行网络传输。<br>传统的套接字发送接口中间需要发生四次数据拷贝。</p>
<h2 id="减少网络开销"><a href="#减少网络开销" class="headerlink" title="减少网络开销"></a>减少网络开销</h2><p>通过以下几种手段减少网络开销</p>
<ul>
<li>批处理</li>
<li>数据压缩降低网络负载</li>
<li>高效的序列化方式</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://jzwdsb.github.io/2019/02/26/zookeeper_in_kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="manout">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="manout's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | manout's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/26/zookeeper_in_kafka/" class="post-title-link" itemprop="url">zookeeper 在 kafka 中的作用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-26 11:00:00" itemprop="dateCreated datePublished" datetime="2019-02-26T11:00:00+08:00">2019-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-18 09:44:32" itemprop="dateModified" datetime="2022-10-18T09:44:32+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>转自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41953232">知乎</a></p>
<h1 id="zookeeper-在分布式集群中的作用"><a href="#zookeeper-在分布式集群中的作用" class="headerlink" title="zookeeper 在分布式集群中的作用"></a>zookeeper 在分布式集群中的作用</h1><h2 id="数据发布与订阅-配置中心"><a href="#数据发布与订阅-配置中心" class="headerlink" title="数据发布与订阅(配置中心)"></a>数据发布与订阅(配置中心)</h2><p>发布与订阅模型，即配置中心，也就是讲发布者将数据发布到 zookeeper 节点上，供订阅者动态获取数据，实现配置的集中式管理和动态更新。<br>例如全局的配置信息，服务框架的地址列表。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>软件负载均衡，最典型的是消息中间件的生产，消费者负载均衡</p>
<h2 id="命名服务-Naming-Service"><a href="#命名服务-Naming-Service" class="headerlink" title="命名服务(Naming Service)"></a>命名服务(Naming Service)</h2><p>常见的是发布者将自己的地址列表写到 zookeeper 的节点，然后订阅者可以从固定名称的节点获取地址列表，链接到发布者进行相关通信</p>
<h2 id="分布式通知-x2F-协调"><a href="#分布式通知-x2F-协调" class="headerlink" title="分布式通知&#x2F;协调"></a>分布式通知&#x2F;协调</h2><p>这个利用的是 zookeeper 的 watch 注册和异步通知机制，能够很好的实现分布式环境中不同系统间的通知与协调，实现对数据变更的实时处理</p>
<h2 id="集群管理与-Master-选举"><a href="#集群管理与-Master-选举" class="headerlink" title="集群管理与 Master 选举"></a>集群管理与 Master 选举</h2><p>集群管理与 Master 选举</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式锁，这个主要得益于 zookeeper 数据的强一致性，利用的是临时节点。锁服务分为两类，一个是独占锁，另一个是控制时序</p>
<p>独占，是指所有的客户端都来获取这把锁，最终只有一个能获取到，用的是临时节点</p>
<p>控制时序，所有来获取锁的客户端，都会被安排得到锁，只不过要有个顺序，实际上是某个节点下的临时顺序子节点来实现的</p>
<h2 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h2><p>一种是 FIFO, 这个就是使用临时顺序节点实现的，和分布式锁服务控制时序一样。</p>
<p>第二种是等待队列的成员聚齐之后的才能同意按序进行。实际上，是在队列的节点里首先创建一个 <code>/queue/num</code> 节点，并且赋值队列的大小。这样我们可以通过监控队列节点子节点的变动来感知队列是否已满或者条件已经满足执行的需要。这种，应用场景是有条件执行的任务，条件齐备了之后任务才能执行。</p>
<h1 id="kafka-使用-zookeeper-实现的服务类型"><a href="#kafka-使用-zookeeper-实现的服务类型" class="headerlink" title="kafka 使用 zookeeper 实现的服务类型"></a>kafka 使用 zookeeper 实现的服务类型</h1><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>Topic 的配置之所以能动态更新就是基于 zookeeper 做了一个动态全局配置管理</p>
<h2 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>基于 zookeeper 的消费者，实现了该特性，动态的感知分区变动，将负载使用既定策略分不到消费者身上</p>
<h2 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h2><p>Broker 将 <code>advertised.port</code> 和 <code>advertised.host.name</code>, 这两个配置发布到 zookeeper 上的 zookeeper 的节点上 <code>/brokers/ids/BrokerId(broker.id)</code>, 这个是供生产者，消费者，其它 Broker 跟其建立连接用户的。</p>
<h2 id="分布式通知"><a href="#分布式通知" class="headerlink" title="分布式通知"></a>分布式通知</h2><p>比如分区增加，topic 变动，Broker 上线下线等均是基于 zookeeper 来实现的分布式通知</p>
<h2 id="集群管理和-master-选举"><a href="#集群管理和-master-选举" class="headerlink" title="集群管理和 master 选举"></a>集群管理和 master 选举</h2><p>可以通过命令行，对 kafka 集群上的 topic partition 分布，进行迁移管理，也可以对 partition leader 选举进行干预</p>
<p>Master 选举，要说有也是违反常规，常规的 master 选举，是基于临时顺序节点来实现的，序列号最小的作为 master. 而 kafka 的 Controller 的选举是基于临时节点来实现的，临时节点创建成功的成为 Controller, 更像一个独占锁服务.</p>
<h2 id="分布式锁-1"><a href="#分布式锁-1" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>独占锁，用于 Controller 的选举.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://jzwdsb.github.io/2019/02/25/idempotent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="manout">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="manout's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | manout's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/25/idempotent/" class="post-title-link" itemprop="url">分布式系统中的幂等性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-25 19:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T19:00:00+08:00">2019-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-18 09:44:32" itemprop="dateModified" datetime="2022-10-18T09:44:32+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>为什么会有这样摸不着头脑的名词(ノಠ益ಠ)ノ彡┻━┻</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/02/25/idempotent/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://jzwdsb.github.io/2019/02/25/kafka_exactly_once/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="manout">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="manout's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | manout's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/25/kafka_exactly_once/" class="post-title-link" itemprop="url">kafka exactly 语义</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-25 10:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T10:00:00+08:00">2019-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-18 09:44:32" itemprop="dateModified" datetime="2022-10-18T09:44:32+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="kafka-事务"><a href="#kafka-事务" class="headerlink" title="kafka 事务"></a>kafka 事务</h1><p>kafka 事务机制的实现主要是为了支持</p>
<ul>
<li><code>Exactly once</code> 刚好一次语义</li>
<li>操作的原子性</li>
<li>有状态操作的原子性</li>
</ul>
<p>在 kafka 0.11.0.0 之前的版本中只支持 <code>At least Once</code> 和 <code>At Most Once</code> 语义，尚不支持 <code>Exactly Once</code> 语义</p>
<h2 id="操作的原子性"><a href="#操作的原子性" class="headerlink" title="操作的原子性"></a>操作的原子性</h2><p>操作的原子性是指，多个操作要么全部成功要么全部失败，不存在部分成功部分失败的可能。<br>实现原子性操作的意义在于</p>
<ul>
<li>操作结果更可控，有助于提升数据一致性</li>
<li>便于故障恢复。因为操作时原子的，从故障中恢复时只需要重试该操作(原操作失败) 或者直接跳过该操作(该操作成功), 而不需要记录中间状态，更不需要针对中间状态作特殊处理</li>
</ul>
<h1 id="实现事务机制的几个阶段"><a href="#实现事务机制的几个阶段" class="headerlink" title="实现事务机制的几个阶段"></a>实现事务机制的几个阶段</h1><h2 id="幂等性发送"><a href="#幂等性发送" class="headerlink" title="幂等性发送"></a>幂等性发送</h2><p>producer 有其特有的 <code>Producer ID</code>(PID) 和 <code>Sequence Number</code>, PID 唯一且透明。<br>对于每个 PID, 该 producer 发送数据的每个 <code>&lt;Topic, Partition&gt;</code> 都对应一个从 0 开始单调递增的 <code>Sequence Number</code>.</p>
<p>类似地, Broker 端也会为每个 <code>&lt;PID, Topic, Partition&gt;</code> 维护一个序号，并且每次 commit 一条消息时将对应序号递增。对于接受的每条消息，如果其序号比 Broker 维护的序号(即最后一次 commit 时的消息的序号) 大一, 则 Broker 会接受它，否则将其丢弃</p>
<ul>
<li>如果消息序号比 Broker 维护的序号大 1 以上，说明中间有数据尚未写入，即乱序，此时 Broker 拒绝该消息，producer 抛出 <code>InvalidSequenceNumber</code></li>
<li>如果消息序号小于等于 Broker 维护的序号，说明该消息已经被保存，即重复消息，Broker 丢弃该消息，Producer 抛出 <code>DuplicateSequenceNumber</code></li>
</ul>
<h2 id="事务性保证"><a href="#事务性保证" class="headerlink" title="事务性保证"></a>事务性保证</h2><p>事务保证可以使得应用程序将生产数据和消费数据当做一个原子单元来处理，要么全部成功，要么全部失败，即使该生产或者消费跨多个 <code>&lt;Topic, Partition&gt;</code>.<br>另外有状态的应用也可以保证重启后从断点处继续处理，也即事务恢复。<br>为了实现这种效果，应用程序必须提供一个稳定的(重启后不变的)唯一的 ID, 也即 <code>Transaction ID</code>. <code>Transaction ID</code> 与 PID 可能一一对应。区别在于 <code>Transaction ID</code> 由用户提供，而 PID 对用户透明。<br>另外，为了保证新的 Producer 启动后，旧的具有相同 <code>Transaction ID</code> 的 Producer 即失效，每次 Producer 通过 Transaction ID 拿到 PID 的同时，还会获取一个单调递增的 epoch. 由于旧的 Producer 的 epoch 比新的 Producer 的 epoch 小，kafka 可以很容易识别出该 Producer 是老的 Producer 并拒绝其请求。</p>
<p>有了 Transaction ID 后，Kafka 可保证</p>
<ul>
<li>跨 Session 的数据幂等发送。当具有相同的 <code>Transaction ID</code> 的新的 Producer 实例被创建且工作时，旧的且拥有相同 <code>Transaction ID</code> 的 Producer 将不再工作.</li>
<li>跨 Session 的事务恢复。如果某个应用实例宕机，新的实例可以保证任何未完成的旧的事务要么 Commit 要么 Abort, 使得新实例从一个正常状态开始恢复</li>
</ul>
<h2 id="完整事务过程"><a href="#完整事务过程" class="headerlink" title="完整事务过程"></a>完整事务过程</h2><ul>
<li>找到 <code>Transaction Coordinator</code></li>
<li>获取 <code>PID</code></li>
<li>开启事务</li>
<li>Consume-Transform-Produce</li>
<li>Commit 或者 Abort 事情</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://jzwdsb.github.io/2019/02/22/kafka_partition_leader_election/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="manout">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="manout's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | manout's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/22/kafka_partition_leader_election/" class="post-title-link" itemprop="url">kafka 高可用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-22 18:00:00" itemprop="dateCreated datePublished" datetime="2019-02-22T18:00:00+08:00">2019-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-18 09:44:32" itemprop="dateModified" datetime="2022-10-18T09:44:32+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文转自<a target="_blank" rel="noopener" href="http://www.jasongj.com/">技术世界</a>, <a target="_blank" rel="noopener" href="http://www.jasongj.com/2015/04/24/KafkaColumn2">原文链接</a></p>
</blockquote>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>kafka 在 0.8 以前的版本中，并不提供 High Availablity 机制，一旦一个或多个 Broker 宕机，则宕机期间其上所有 partitions 都无法继续提供服务。若该 Broker 不能恢复，或者磁盘故障，则其数据将丢失。</p>
<p>kafka 从 0.8 版本开始提供的 High Availability 主要包含两方面</p>
<ul>
<li>Data Replication</li>
<li>Leader Election</li>
</ul>
<h1 id="Data-Repliction"><a href="#Data-Repliction" class="headerlink" title="Data Repliction"></a>Data Repliction</h1><p>kafka 的 data repliction 需要解决如下问题</p>
<ul>
<li>怎样 propagate 消息</li>
<li>在想 producer 发送 ACK 前需要保证有多少个 Replica 已经收到该消息</li>
<li>怎样处理某个 Replica 不工作的情况</li>
<li>怎样处理 Failed Replica 恢复回来的情况</li>
</ul>
<h2 id="replica"><a href="#replica" class="headerlink" title="replica"></a>replica</h2><p>引入 data repliction 后，一个 partitions 可以多个 replica。<br>如果这些 replica 在一个 broker 上，那么当这个 broker 宕机时，这个 partitions 仍然不可用，所以这些 replica 会分布在多个 broker 上.</p>
<h2 id="propagate-信息"><a href="#propagate-信息" class="headerlink" title="propagate 信息"></a>propagate 信息</h2><h3 id="leader"><a href="#leader" class="headerlink" title="leader"></a>leader</h3><p>这些 replica 通过 leader election 选举 leader, 其余为 follower. leader 承载 producer 的 push 请求，并将消息写入本地 log, 其他 follower 从其 leader 中 pull 数据.<br>leader 会维持一个与其基本保持同步的 Replica 列表，该列表成为 ISR(In-Sync Replica), 每个 Partitions 都会有一个 ISR, 并由 leader 动态维护</p>
<h3 id="follower"><a href="#follower" class="headerlink" title="follower"></a>follower</h3><p>follower 在 pull 到消息并写入 log 后，向 leader 发送 ACK.</p>
<h3 id="producer-commit"><a href="#producer-commit" class="headerlink" title="producer commit"></a>producer commit</h3><p>在 ISR 列表中的 replica 都已经向 leader 发送 ACK 后，leader 则认为该 message 成功 commit, leader 将增加 HW(high watermark, 该 offset 前 record 认为已经备份) 并向 producer 发送 ACK.<br>为了提高性能，其他 follower 是在收到消息后立即发送 ACK, 而不是等到写入 log 后，因此已经 commit, leader 只能保证目前存于其他 follower 的内存中，而不是持久化到磁盘中，所以也就不能保证该消息一定能被消费，但是这种场景属于极端场景，比较少见。<br>Consumer 读消息也是从 leader 读取，只有被 commit 的消息(offset 低于 HW 的消息), 才会暴露给 Consumer.</p>
<h2 id="ACK-前需要保证有多少备份"><a href="#ACK-前需要保证有多少备份" class="headerlink" title="ACK 前需要保证有多少备份"></a>ACK 前需要保证有多少备份</h2><p>kafka 处理失败需要明确定义一个 Broker 是否活着，对于 Kafka 而言，Kafka 存活包含两个条件，一是它必须维护与 Zookeeper 的 Session(通过 Zookeeper 的 HeartBeat 机制来实现). 二是 Follower 必须能够及时拉取 Leader 的消息，不能落后太多。</p>
<p>Leader 会维护一个 ISR 列表. 如果一个 follower 宕机，或者落后太多，Leader 将把他从 ISR 中移除。这里的落后太多指 Follower 复制的消息落后于 Leader 后的条数超过预定值(<code>replica.lag.max.messages</code>, 默认为 4000), 或者 Follower 超过一定时间(<code>replica.lag.time.max.ms</code>, 默认为 1000) 未向 Leader 发送 fetch 请求。</p>
<p>kafka 的复制机制既不是完全的同步复制，也不是单纯额异步复制。事实上，同步复制要求所有能工作的 Follower 都要复制完，这条消息才会被认为 commit, 这种复制方式会极大地影响吞吐量。而异步复制方式下，Follower 异步的从 Leader 复制数据，数据只要被 Leader 写入 log 就认为已经 commit, 这种情况下如果 follower 都复制完都落后于 leader, 而如果 Leader 突然宕机，则会丢失数据。而 Kafka 这种使用 ISR 的方式则很好的均衡了数据不丢失以及吞吐量。Follower 可以批量的从 Leader 复制数据，这样极大地提高复制性能(批量写磁盘), 极大减少了 Follower 与 Leader 的差距.</p>
<h1 id="Leader-Election"><a href="#Leader-Election" class="headerlink" title="Leader Election"></a>Leader Election</h1><p>当 leader 宕机后，如何在 follower 中选举出新的 leader.<br>一个基本的原则就是，如果 leader 不再了，新的 leader 必须有原来的 leader commit 过的所有消息。</p>
<p>kafka 在 ZooKeeper 中动态维护了一个 ISR(In-sync replics), 这个 ISR 里的所有 Replica 都跟上了 leader, 只有 ISR 里的成员才有被选为 Leader 的可能。在这种模式下，对于 f + 1 个 Replica, 一个 Partitions 能在保证不丢失已经 commit 的消息的前提下容忍 f 个 Replica 的失败。<br>为了容忍 f 个 Replica 的失败，Majority Vote 和 ISR 在 commit 前需要等待的 Replica 数量是一样的，但是 ISR 需要的总的 Replica 的个数几乎是 Majority Vote 的一半。</p>
<h2 id="ISR-中所有-Replica-都宕机"><a href="#ISR-中所有-Replica-都宕机" class="headerlink" title="ISR 中所有 Replica 都宕机"></a>ISR 中所有 Replica 都宕机</h2><p>当 ISR 中至少有一个 Replica 时，kafka 保证 commit 的数据不丢失，但是如果某个 partition 的所有 Replica 都宕机了，就无法保证数据不丢失了。这种情况下有两种可行方案</p>
<ul>
<li>等待 ISR 中的任意一个 Replica 恢复，并将其选为 Leader</li>
<li>选择第一个恢复的 Replica(不一定在 ISR 中) 作为 Leader</li>
</ul>
<p>这就需要在可用性和一致性当中做出一个简单的折衷。如果一定要等待 ISR 中的 Replica 恢复，那不可用的时间可能会比较长，而且如果这个 Partitions 的 ISR 中的所有 Replica 都无法活过来了，或者数据都丢失了，这个 Partition 将永远不可用。</p>
<p>kafka 选择第二种方式处理这种情况，在未来的版本中，将支持通过配置选择两种方式中的一种。</p>
<h2 id="如何选举-leader"><a href="#如何选举-leader" class="headerlink" title="如何选举 leader"></a>如何选举 leader</h2><p>所有的 follower 在 zookeeper 上设置一个 watch, 一旦 leader 宕机，其对应的 ephemeral znode 自动删除，此时所有 follower 都尝试创建该节点，创建成功者(zookeeper 保证只有一个能创建成功) 即是新的 Leader, 其它 Replica 即为 Follower.<br>但是该方法会有 3 个问题</p>
<ul>
<li>split-brain<br>由 zookeeper 的特性引起，虽然 Zookeeper 能保证 Watch 按顺序触发，但并不能保证同一时刻所有 Replica 看到状态的是一样的，这就可能造成不同的 Replica 的响应不一致</li>
<li>herd effect<br>如果宕机的那个 broker 上的 partition 较多，会造成多个 watch 被触发，造成集群内大量的调整</li>
<li>Zookeeper<br>Zookeeper 负载过重，每个 Replica 都要为此在 Zookeeper 上注册一个 Watch, 当集群规模增加到几千个 Partition 时 Zookeeper 负载会过重</li>
</ul>
<p>在 kafka 0.8.* 的 leader Election 方案解决上述问题，他在所有 broker 中选出一个 controller, 所有 Partition 的 Leader 都由 Controller 决定。Controller 会将 Leader 的改变直接通过 RPC 的方式(比 Zookeeper queue 更高效) 通知需为此做出相应的 broker, 同时 controller 也负责增删 Topic 以及 Replica 的重新分配。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://jzwdsb.github.io/2019/02/21/kafka_consumer_offset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="manout">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="manout's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | manout's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/21/kafka_consumer_offset/" class="post-title-link" itemprop="url">kafka consumer 手动设置 offset 的确认问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-21 11:00:00" itemprop="dateCreated datePublished" datetime="2019-02-21T11:00:00+08:00">2019-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-18 09:44:32" itemprop="dateModified" datetime="2022-10-18T09:44:32+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>使用 kafka consumer 要手动设置 offset 就需要使用 kafka low level consumer API, 从而更好的控制消费, 比如如下场景</p>
<ul>
<li>同一条消息读多次</li>
<li>只读取某个 topic 的部分 partition</li>
<li>管理事务，从而确保每条消息被处理一次，且仅被处理一次</li>
</ul>
<p>与 consumer Group 相比，Low Level Consumer 要求用户做大量的额外工作</p>
<ul>
<li>必须在应用程序中跟踪 offset, 从而确定下一条应该消费哪条消息</li>
<li>应用程序需要通过程序获知每个 Partition 的 Leader 是谁</li>
<li>必须处理 Leader 的变化</li>
</ul>
<p>使用 Low Level Consumer 的一般流程如下</p>
<ul>
<li>查找到一个活着的 Broker, 并且找出每个 Partition 的 Leader</li>
<li>找出每个 Partition 的 Follower</li>
<li>定义好请求，该请求应该能描述应用程序需要哪些数据</li>
<li>Fetch 数据</li>
<li>识别 Leader 的变化，并对其作出必要的响应</li>
</ul>
<h1 id="消费端手动设置-offset-的确认"><a href="#消费端手动设置-offset-的确认" class="headerlink" title="消费端手动设置 offset 的确认"></a>消费端手动设置 offset 的确认</h1><p>kafka 如果要自己手动设置 offset, 需要手动 commit 通知 topic 该信息已经消费。</p>
<p>比如接受到了 [1, 2, 3, 4, 5] 消息，这里处理时 [1, 2, 3, 4,] 消息消费失败，没有 commit, 但是消息 5 消费成功，成功 commit, 此时 offset 会重置到 5, 但其实之前的 1, 2, 3, 4 没有丢失，仍然保存在 kafka 中，下一次消费时会直接从 offset 取一个 batchSize 数量的信息，做如上的处理。</p>
<h2 id="commitSync"><a href="#commitSync" class="headerlink" title="commitSync"></a>commitSync</h2><p>该方法是 kafka consumer 手动设置 offset 后，应当调用的 commit 方法，以便 kafka 重置 offset.</p>
<p>官方文档说该方法提交的 offset 会成为 kafka rebalance 和 startup 之后的 first fetch, 也就是说使用该方法提交 offset 之后，offset 会被设置为该值，下次读取会从该 offset fetch. 因此，此时手动提交 offset 需要在消费端自己维护 offset.</p>
<h1 id="offset-和-consumer-position"><a href="#offset-和-consumer-position" class="headerlink" title="offset 和 consumer position"></a>offset 和 consumer position</h1><p>kafka offset 是一条记录的唯一标识，同样也是 consumer 在这个 partition 的下次应当消费的位置。<br>关于 consumer 在 partition 实际上有两个概念.<br>consumer position 保存在一个特殊 topic, <code>_consumer_offset</code> 中。</p>
<ul>
<li>offset</li>
<li>committed position</li>
</ul>
<h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p>position 为下一条应当交付给 consumer 的记录。将会等于 consumer 已经在这个 partition 中拉取的 offset 的 + 1, 这个值每当 consumer 调用 <code>poll</code>(java 接口，其他语言类似) 会自动更新。</p>
<h2 id="committed-position"><a href="#committed-position" class="headerlink" title="committed position"></a>committed position</h2><p>committed position 是最后一次确认消费的 offset.<br>默认行为是周期性的自动 commit, 也可以手动调用 consumer 的 <code>commitSync</code> 和 <code>commitAsync</code> 手动提交 offset.<br>committed position 是 consumer 宕机恢复时重新读取的 offset, 也是发生 rebalance 时, 原来未消费过该 partitions 的 consumer 分配到该 partitions 时读取的 offset.</p>
<h1 id="consumer-探活"><a href="#consumer-探活" class="headerlink" title="consumer 探活"></a>consumer 探活</h1><p>当 consumer 订阅一个 topic 后，consumer 调用 <code>poll</code> 时会自动加入 consumer group.<br><code>poll</code> API 有保活机制。在底层实现中，会定期发送心跳给 server. 如果在 <code>session.timeout.ms</code> 时间间隔后 consumer 仍没有发送心跳，该 consumer 就会被为宕机，触发 rebalance.</p>
<p>consumer 可能会处于 <code>livelock</code> 情况，也就是 consumer 仍在定时发送心跳，但是却没有进行消费，就是从其对应的 partitions poll 消息，这种情况下 consumer 处于保活，但是不再活跃，占用资源。同样也有相关机制来防止，如果 consumer 在 <code>max.poll.interval.ms</code> 时间间隔后没有调用 <code>poll</code> 从 partitions 拉取数据，那么就会被移出其所在 consumer group, 方便其他 consumer 能够消费该 partitions.<br>当以上情况发生时，该 consumer 会发生一次 commit failure, 由 <code>commitSync</code>, 抛出一个 <code>CommitFailException</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://jzwdsb.github.io/2019/02/19/redis_cluster/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="manout">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="manout's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | manout's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/19/redis_cluster/" class="post-title-link" itemprop="url">redis cluster 节点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-19 19:00:00" itemprop="dateCreated datePublished" datetime="2019-02-19T19:00:00+08:00">2019-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-18 09:44:32" itemprop="dateModified" datetime="2022-10-18T09:44:32+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="redis-节点相关"><a href="#redis-节点相关" class="headerlink" title="redis 节点相关"></a>redis 节点相关</h1><p>每个 redis cluster 中的节点都有集群当前的配置信息，给出以下信息</p>
<ul>
<li>当前已知的节点</li>
<li>与其他节点的连接的信息</li>
<li>标志</li>
<li>属性</li>
<li>赋予的 slots</li>
</ul>
<p><code>cluster nodes</code> 命令可以得到与当前终端连接的节点所属的集群上面的信息。格式与 redis 在硬盘上保存信息的格式相同。</p>
<h1 id="序列化格式"><a href="#序列化格式" class="headerlink" title="序列化格式"></a>序列化格式</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">07c37dfeb235213a872192d90877d0cd55635b91 127.0.0.1:30004 slave e7d1eecce10fd6bb5eb35b9f99a514335d9ba9ca 0 1426238317239 4 connected</span><br><span class="line">67ed2db8d677e59ec4a4cefb06858cf2a1a89fa1 127.0.0.1:30002 master - 0 1426238316232 2 connected 5461-10922</span><br><span class="line">292f8b365bb7edb5e285caf0b7e6ddc7265d2f4f 127.0.0.1:30003 master - 0 1426238318243 3 connected 10923-16383</span><br><span class="line">6ec23923021cf3ffec47632106199cb7f496ce01 127.0.0.1:30005 slave 67ed2db8d677e59ec4a4cefb06858cf2a1a89fa1 0 1426238316232 5 connected</span><br><span class="line">824fe116063bc5fcf9f4ffd895bc17aee7731ac3 127.0.0.1:30006 slave 292f8b365bb7edb5e285caf0b7e6ddc7265d2f4f 0 1426238317741 6 connected</span><br><span class="line">e7d1eecce10fd6bb5eb35b9f99a514335d9ba9ca 127.0.0.1:30001 myself,master - 0 0 1 connected 0-5460</span><br></pre></td></tr></table></figure>

<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>输出格式为如下的 CSV 格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;id&gt; &lt;ip:port&gt; &lt;flags&gt; &lt;master&gt; &lt;ping-sent&gt; &lt;pong-recv&gt; &lt;config-epoch&gt; &lt;link-state&gt; &lt;slot&gt; &lt;slot&gt; ... &lt;slot&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>id<br>长度为 40 的随机字符串，在一个创建一个节点生成并不再改变</li>
<li>ip:port<br>该节点的 ip 和 port</li>
<li>flags<br>由 <code>,</code> 分割的 <code>myself</code>, <code>master</code>, <code>slave</code>, <code>fail?</code>, <code>fail</code>, <code>handshake</code>, <code>noaddr</code>, <code>noflags</code></li>
<li>master 如果该节点非 master 节点且 master 节点已知，则这里应为 master id, 否则为 -</li>
<li>ping-sent unix 当前发送活跃 ping 的毫秒时间戳</li>
<li>pong-recv 最后一次收到 pong 的时间戳</li>
<li>config-epoch 节点的目前的配置版本</li>
<li>link-state 集群中节点间的连接总线状态，可以为 <code>connected</code> 或者 <code>disconnected</code></li>
<li>slot 一个哈希 slot 数字或者区间，从 9 开始，最大为 16384. 这是每个节点各自维护的哈希槽.</li>
</ul>
<h2 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h2><ul>
<li>myself 当前连接的节点</li>
<li>master 这个节点为 master 节点</li>
<li>slave slave 节点</li>
<li>fail? 节点处于 <code>PFAIL</code> 状态，对于当前连接的节点不可达，但是逻辑上可达</li>
<li>fail 节点处于 <code>FAIL</code> 状态，对于多个节点都不可达，从 <code>PFAIL</code> 状态转来</li>
<li>handshake 不可信任的节点，当前正在握手</li>
<li>noaddr 这个节点的地址不可知</li>
<li>noflags</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiazhenwei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
